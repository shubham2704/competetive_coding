/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using ld = long double;
template<typename T, typename U = T>
using P = pair<T, U>;
template<typename T>
using V = vector<T>;
using VI = vector<int>;
using VL = vector<long long>;
//#pragma GCC optimize("O3")
//#pragma GCC target("avx2")
//#pragma GCC target("avx512f")
//#pragma GCC optimize("unroll-loops")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
//#pragma GCC optimize("Ofast")

#define G(size_1) vector<vector<int>>(size_1, vector<int>())
#define SZ(x) ((long long)(x).size())
#define READ ({long long t;cin >> t;t;})

#define FOR(i, __begin, __end) for (auto i = (__begin) - ((__begin) > (__end)); i != (__end) - ((__begin) > (__end)); i += 1 - 2 * ((__begin) > (__end)))
#define overload4(_1, _2, _3, _4, name, ...) name
#define REP1(n) for(ll i=0;i<n;++i)
#define REP2(i, n) for(ll i=0;i<n;++i)
#define REP3(i, a, b) for(ll i=a;i<b;++i)
#define REP4(i, a, b, c) for(ll i=a;i<b;i+=c)
#define REP(...) overload4(__VA_ARGS__,REP4,REP3,REP2,REP1)(__VA_ARGS__)
#define RREP1(n) for(ll i=n;i--;)
#define RREP2(i, n) for(ll i=n;i--;)
#define RREP3(i, a, b) for(ll i=b;i-->(a);)
#define RREP4(i, a, b, c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)
#define RREP(...) overload4(__VA_ARGS__,RREP4,RREP3,RREP2,RREP1)(__VA_ARGS__)
#define ALL(x) (x).begin(),(x).end()
#define RALL(x) (x).rbegin(),(x).rend()
#define F first
#define S second
#define y0 y3487465
#define y1 y8687969
#define j0 j1347829
#define j1 j234892
#define BIT(n) (1LL<<(n))
#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )
#define EB emplace_back
#define PB push_back
#define fcout cout << fixed << setprecision(12)
#define fcerr cerr << fixed << setprecision(12)
#define print(...) out(cout, __VA_ARGS__)
#define fprint(x) cout << fixed << setprecision(12) << (x) << '\n'
# define BYE(a) do { cout << (a) << endl; return ; } while (false)
#define LB lower_bound
#define UB upper_bound
#define LBI(c, x) distance((c).begin(), lower_bound((c).begin(), (c).end(), (x)))
#define UBI(c, x) distance((c).begin(), upper_bound((c).begin(), (c).end(), (x)))

#ifdef DEBUG
#define DBG(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); }
#define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(std::cerr,_it, args); }
#else
#define DBG(args...) {};
#define ERR(args...) {};
#endif

void _err(std::ostream& cerr, istream_iterator<string> it){cerr << endl;}

template<typename T, typename... Args>
void _err(std::ostream& cerr, istream_iterator<string> it, T a, Args... args){
    cerr << *it << " = " << a << "  ";
    _err(cerr, ++it, args...);
}

template<class T>
int out(ostream& os, const T& t){
    os << t << '\n';
    return 0;
}

template<class Head, class... Tail>
int out(ostream& os, const Head& head, const Tail& ... tail){
    os << head << ' ';
    out(os, tail...);
    return 0;
}

namespace aux{
    template<std::size_t...>
    struct seq{
    };

    template<std::size_t N, std::size_t... Is>
    struct gen_seq : gen_seq<N - 1, N - 1, Is...>{
    };

    template<std::size_t... Is>
    struct gen_seq<0, Is...> : seq<Is...>{
    };

    template<class Ch, class Tr, class Tuple, std::size_t... Is>
    void print_tuple(std::basic_ostream<Ch, Tr>& os, Tuple const& t, seq<Is...>){
        using swallow = int[];
        (void) swallow{0, (void(os << (Is == 0 ? "" : ",") << std::get<Is>(t)), 0)...};
    }

    template<class Ch, class Tr, class Tuple, std::size_t... Is>
    void read_tuple(std::basic_istream<Ch, Tr>& os, Tuple& t, seq<Is...>){
        using swallow = int[];
        (void) swallow{0, (void(os >> std::get<Is>(t)), 0)...};
    }
} // aux::

template<class Ch, class Tr, class... Args>
auto operator<<(std::basic_ostream<Ch, Tr>& os, std::tuple<Args...> const& t)
-> std::basic_ostream<Ch, Tr>&{
    os << "(";
    aux::print_tuple(os, t, aux::gen_seq<sizeof...(Args)>());
    return os << ")";
}

template<class Ch, class Tr, class... Args>
auto operator>>(std::basic_istream<Ch, Tr>& os, std::tuple<Args...>& t)
-> std::basic_istream<Ch, Tr>&{
    aux::read_tuple(os, t, aux::gen_seq<sizeof...(Args)>());
    return os;
}

template<class T>
auto min(T& v){
    return *min_element(v.begin(), v.end());
}

template<class T>
auto max(T& v){
    return *max_element(v.begin(), v.end());
}

template<class U = long long, class T>
auto sum(T& v){
    return accumulate(v.begin(), v.end(), (U) 0);
}


template<typename T, typename U>
istream& operator>>(istream& is, pair <T, U>& V){
    is >> V.F >> V.S;
    return is;
}

template<typename T>
istream& operator>>(istream& is, vector <T>& V){
    for(auto&& ele : V)is >> ele;
    return is;
}

template<typename T>
ostream& operator<<(ostream& os, const vector <T> V){
    os << "[";
    int cnt = 0;
    T curr;
    if(!V.empty()){
        for(int i = 0; i < V.size() - 1; ++i){
            if(V[i] == curr)cnt++;
            else cnt = 0;
            if(cnt == 4)os << "... ";
            if(cnt < 4)
                os << i << ":" << V[i] << " ";
            curr = V[i];
        }
        os << V.size() - 1 << ":" << V.back();
    }
    os << "]\n";
    return os;
}

template<typename T, typename U>
ostream& operator<<(ostream& os, const pair <T, U> P){
    os << "(";
    os << P.first << "," << P.second;
    os << ")";
    return os;
}

template<typename T, typename U>
ostream& operator<<(ostream& os, const set <T, U> V){
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for(int i = 0; i < V.size() - 1; ++i){
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}\n";
    return os;
}

template<typename K, typename H, typename P>
ostream& operator<<(ostream& os, const unordered_set <K, H, P> V){
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for(int i = 0; i < V.size() - 1; ++i){
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}\n";
    return os;
}

template<typename K, typename C>
ostream& operator<<(ostream& os, const multiset <K, C> V){
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for(int i = 0; i < V.size() - 1; ++i){
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}";
    return os;
}

template<typename K, typename T, typename C>
ostream& operator<<(ostream& os, const map <K, T, C> V){
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for(int i = 0; i < V.size() - 1; ++i){
            os << "(";
            os << it->first << "," << it->second;
            os << ") ";
            it++;
        }
        os << "(";
        os << it->first << "," << it->second;
        os << ")";
    }
    os << "}\n";
    return os;
}

template<typename K, typename T, typename C>
ostream& operator<<(ostream& os, const unordered_map <K, T, C> V){
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for(int i = 0; i < V.size() - 1; ++i){
            os << "(";
            os << it->first << "," << it->second;
            os << ") ";
            it++;
        }
        os << "(";
        os << it->first << "," << it->second;
        os << ")";
    }
    os << "}\n";
    return os;
}

template<typename T>
ostream& operator<<(ostream& os, const deque <T> V){
    os << "[";
    if(!V.empty()){
        for(int i = 0; i < V.size() - 1; ++i){
            os << V[i] << "->";
        }
        if(!V.empty())os << V.back();
    }
    os << "]\n";
    return os;
};

template<typename T, typename Cont, typename Comp>
ostream& operator<<(ostream& os, const priority_queue<T, Cont, Comp> V){
    priority_queue<T, Cont, Comp> _V = V;
    os << "[";
    if(!_V.empty()){
        while(_V.size() > 1){
            os << _V.top() << "->";
            _V.pop();
        }
        os << _V.top();
    }
    os << "]\n";
    return os;
};

template<class F>
struct y_combinator{
    F f; // the lambda will be stored here

    // a forwarding operator():
    template<class... Args>
    decltype(auto) operator()(Args&& ... args) const{
        // we pass ourselves to f, then the arguments.
        // the lambda should take the first argument as `auto&& recurse` or similar.
        return f(*this, std::forward<Args>(args)...);
    }
};

// helper function that deduces the type of the lambda:
template<class F>
y_combinator<std::decay_t<F>> recursive(F&& f){
    return {std::forward<F>(f)};
}

struct hash_pair{
    template<class T1, class T2>
    size_t operator()(const pair <T1, T2>& p) const{
        auto hash1 = hash<T1>{}(p.first);
        auto hash2 = hash<T2>{}(p.second);
        return hash1^hash2;
    }

};

template<typename U>
auto vec(int n, U v){
    return std::vector(n, v);
}

template<typename... Args>
auto vec(int n, Args... args){
    auto val = vec(std::forward<Args>(args)...);
    return std::vector<decltype(val)>(n, std::move(val));
}

const double PI = 2*acos(.0);
const int INF = 0x3f3f3f3f;

template<class T>
inline T ceil(T a, T b){return (a + b - 1)/b;}

inline long long popcount(ll x){return __builtin_popcountll(x);}

ll powi(ll a, ll b){
    ll res = 1;
    while(b){
        if(b&1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}

ll powp(ll a, ll b, ll p){
    ll res = 1;
    while(b){
        if(b&1) (res *= a) %= p;
        (a *= a) %= p;
        b >>= 1;
    }
    return res;
}

template<class T>
inline bool chmax(T& a, const T& b){
    if(a < b){
        a = b;
        return 1;
    }
    return 0;
}

template<class T>
inline bool chmin(T& a, const T& b){
    if(b < a){
        a = b;
        return 1;
    }
    return 0;
}

void solve(std::istream& cin, std::ostream& cout, std::ostream& cerr){
    auto solve = [&](){
        int N, Q;
        cin >> N >> Q;
        if(N == 1){
            string s;
            int score;
            cin >> s >> score;
            if(score > Q/2)cout << s << " " << score << "/1" << '\n';
            else{
                for(auto&& c : s)c = 'F' + 'T' - c;
                cout << s << " " << Q - score << "/1" << '\n';
            }
        }else{
            string s, t;
            int score_s, score_t;
            cin >> s >> score_s >> t >> score_t;
            if(score_s <= Q/2){
                score_s = Q  -score_s;
                for(auto&& c : s)c = 'F' + 'T' - c;
            }
            if(score_t<=Q/2){
                score_t = Q - score_t;
                for(auto&& c : t)c = 'F' + 'T' - c;
            }
            if(score_s>=score_t)cout << s << " " << score_s << "/1" << '\n';
            else cout << t << " " << score_t << "/1" << '\n';
        }
    };

    int testcases;
    cin >> testcases;
    for(int case_num = 1; case_num <= testcases; case_num++){
        cout << "Case #" << case_num << ": ";
        solve();
    }
}







#undef int
int main() {
	istream& in(cin);
    ostream& out(cout);
    ostringstream err;
	in.tie(0); ios::sync_with_stdio(0);
    solve(in, out, err);
	return 0;
}
